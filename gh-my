#!/usr/bin/env bash
set -eo pipefail

TEMPLATE='{{tablerow "Num" "Title" "Who" "URL" "When" -}}
{{range(pluck "node" .data.search.edges) -}}
{{tablerow (printf "#%v" .number | autocolor "green") .title .author.login (.url | autocolor "cyan") (timeago .createdAt)  -}}
{{end -}}
{{tablerender}}'

function query_help()
{
  cat << EOF

Usage: gh my [issues|prs|reviews|workload|report|deployments] [options]
  issues      : list issues in your personal repositories
  prs         : list PRs in your persional repositories
  reviews     : list PRs where you've been asked for a review
  workload    : list PRs and issues where you are the assignee
  deployments : list deployments awaiting action on the default branch
  report      : show all the issues & prs you've worked on in the last 14 days
                (because you have to tell people what you've done)

Listing deployments needs more filters
  -o : the organisation (e.g. -o my-company)
  -t : the topic  (e.g. -o my-terraform-repos)
  -r : a specific repository, but why not use gh run list instead?

Report generation uses 'date' so any gnu date string is valid
  -d : the date string (default is "14 days ago")
  -q : omit the table headers

EOF
 exit 1
}

function query_workload() {
  # shellcheck disable=SC2016
  query='query ($endCursor: String){
          search(query: "is:open assignee:@me archived:false",after: $endCursor, type: ISSUE, first: 50) {
            edges {
              node {
                ... on PullRequest {
                  number
                  title
                  author {
                    login
                  }
                  reviewDecision
                  createdAt
                  url
                  repository {
                    nameWithOwner
                    name
                  }
                }
                ... on Issue {
                  number
                  title
                  author {
                    login
                  }
                  createdAt
                  url
                  repository {
                    nameWithOwner
                    name
                  }
                }
              }
            }
            pageInfo {
              hasNextPage
              endCursor
            }
          }
        }'
  gh api graphql --paginate --raw-field query="$(internal::compressQuery "$query")" --template "$TEMPLATE"
}

function query_reviews() {
  # shellcheck disable=SC2016
  query='query ($endCursor: String){
          search(query: "is:open is:pr review-requested:@me archived:false", after: $endCursor, type: ISSUE, first: 50) {
            edges {
              node {
                ... on PullRequest {
                  number
                  title
                  author {
                     login
                  }
                  reviewDecision
                  createdAt
                  url
                  repository {
                    nameWithOwner
                    name
                  }
                }
              }
            }
            pageInfo {
              hasNextPage
              endCursor
            }
          }
        }'
  gh api graphql --paginate --raw-field query="$(internal::compressQuery "$query")" --template "$TEMPLATE"
}

function query_issues() {
  # shellcheck disable=SC2016
  query='query ($endCursor: String) {
          search(query: "is:open is:issue user:@me archived:false", type: ISSUE, after: $endCursor, first: 50) {
            edges {
              node {
                ... on Issue {
                  number
                  title
                  author {
                    login
                  }
                  createdAt
                  url
                  repository {
                    nameWithOwner
                    name
                  }
                }
              }
            }
            pageInfo {
              hasNextPage
              endCursor
            }
          }
        }'
  gh api graphql --paginate --raw-field query="$(internal::compressQuery "$query")" --template "$TEMPLATE"
}

function query_prs() {
  # shellcheck disable=SC2016
  query='query ($endCursor: String) {
          search(query: "is:open is:pr user:@me archived:false", type: ISSUE, after: $endCursor, first: 50) {
            edges {
              node {
                ... on PullRequest {
                  number
                  title
                  author {
                    login
                  }
                  createdAt
                  url
                  repository {
                    nameWithOwner
                    name
                  }
                }
              }
            }
            pageInfo {
              hasNextPage
              endCursor
            }
          }
        }'
  gh api graphql --paginate --raw-field query="$(internal::compressQuery "$query")" --template "$TEMPLATE"
}

function query_deployments() {
  org=''
  topic=''
  repo=''
  while getopts 'o:t:r:' flag; do
    case "${flag}" in
    o) org="org:${OPTARG}" ;;
    t) topic="topic:${OPTARG}" ;;
    r) repo="${OPTARG}" ;;
    *) query_help ;;
    esac
  done
  if [[ "$org" == "" && $topic = "" && $repo = "" ]]; then
    query_help
  fi
  if [[ $repo != "" ]]; then
    internal::repo_deploys "$repo"
  else
    queryString="$org $topic"
    internal::org_deploys "$queryString"
  fi
}

# Get all the issues & PRs authored by me in the last 14 days.
# Potentially shouldn't have issues, since issues created by me might be worked on by me
# Issues assigned to me will eventually have a PR created by me.
# PR's assigned to me are a category mystery, why assigned as opposed to review.
function query_report() {
  report_header='{{tablerow "Num" "Title" "Repository" "URL" "Last Activity" -}}'
  report_data='
{{range(pluck "node" .data.search.edges) -}}
{{tablerow (printf "#%v" .number | autocolor "green") .title (.repository.nameWithOwner | autocolor "yellow") (.url | autocolor "cyan") (timefmt "02-Jan" .updatedAt)  -}}
{{end -}}
{{tablerender}}
'
  include_headers=true
  since='14 days ago'
  while getopts 'd:q' flag; do
    case "${flag}" in
    d) since="${OPTARG}" ;;
    q) include_headers=false ;;
    *) query_help ;;
    esac
  done

  report_template="$report_data"
  if [[ "$include_headers" == "true" ]]; then
    report_template="$report_header $report_data"
  fi

  queryString="author:@me updated:>=$(date --date="$since" '+%Y-%m-%d') archived:false sort:updated"
  # shellcheck disable=SC2016
  query='query ($queryString: String!, $endCursor: String){
          search(query: $queryString,after: $endCursor, type: ISSUE, first: 50) {
            edges {
              node {
                ... on PullRequest {
                  number
                  title
                  author {
                    login
                  }
                  reviewDecision
                  updatedAt
                  url
                  repository {
                    nameWithOwner
                  }
                }
                ... on Issue {
                  number
                  title
                  author {
                    login
                  }
                  updatedAt
                  url
                  repository {
                    nameWithOwner
                  }
                }
              }
            }
            pageInfo {
              hasNextPage
              endCursor
            }
          }
        }'
  gh api graphql --paginate -F queryString="$queryString" --raw-field query="$(internal::compressQuery "$query")" --template "$report_template"
}

# Query a specific repo for any deployments that are in a "waiting" state
function internal::repo_deploys() {
  repo="$1"
  # shellcheck disable=SC2016
  deploy_template='{{tablerow "ID" "URL" "Branch" "When" -}}
{{ range . -}}
{{tablerow (.databaseId | autocolor "green") (.url | autocolor "cyan") (.headBranch | autocolor "yellow") (timeago .startedAt) -}}
{{end -}}'
  gh run list --repo "$repo" --json "databaseId,url,headBranch,startedAt" --template "$deploy_template" -s "waiting"
}

# Query the org, (filtering by topic) listing deploymens in a waiting state that on the default branch
function internal::org_deploys() {
  queryString="$1"
  # shellcheck disable=SC2016
  deploy_template='{{tablerow "ID" "URL" "Branch" "Repo" "Env" "Actionable" "When" -}}
{{range(pluck "node" .data.search.edges) -}}
{{ $repo:=.nameWithOwner -}}{{ $branch:=.defaultBranchRef.name -}}
{{range(pluck "workflowRun" .defaultBranchRef.target.checkSuites.nodes) -}}{{ $workflowId:= .databaseId -}}{{ $workflowRunURL:= .url -}}
{{range .checkSuite.checkRuns.nodes -}}
{{tablerow ($workflowId | autocolor "green")
          ($workflowRunURL | autocolor "cyan")
          ($branch | autocolor "yellow")
          $repo
          .pendingDeploymentRequest.environment.name
          .pendingDeploymentRequest.currentUserCanApprove
          (timeago .startedAt) -}}
{{end -}}
{{end -}}
{{end -}}
'
  # shellcheck disable=SC2016
  query='query ($queryString: String!, $endCursor: String) {
  search(query: $queryString, type: REPOSITORY, first: 100, after: $endCursor) {
    edges {
      node {
        ... on Repository {
          nameWithOwner
          defaultBranchRef {
            name
            target {
              ... on Commit {
                checkSuites(filterBy: {appId: 15368}, last: 1) {
                  nodes {
                    workflowRun {
                      databaseId
                      url
                      checkSuite {
                        checkRuns(filterBy: {status: WAITING}, last: 1) {
                          nodes {
                            startedAt
                            pendingDeploymentRequest {
                              environment {
                                name
                              }
                              currentUserCanApprove
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}'
  gh api graphql --paginate -F queryString="$queryString" --raw-field query="$(internal::compressQuery "$query")" --template "$deploy_template"
}


# This is clearly a bout of premature optimisation and saving
# a few newlines & spaces shouldn't be high on anyone's list
function internal::compressQuery() {
  echo "$1" | tr -d '\n'
}


ACTION=$1 || true
ACTION=${ACTION:="help"}
if [[ "$#" -ne "0" ]]; then shift; fi
"query_${ACTION}" "$@"

